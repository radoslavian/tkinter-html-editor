HtmlText - opis działania:

Wymogi:
+ koloruje:
 - kolor1 (brązowy): tagi otwierające, nazwy tagów, tagi zamykające
 - nazwy atrybutów (pomarańczowy)
 - zawartość atrybutów (fioletowy)
 - dane np. między znacznikami <style></style>, <script></script>
 - komentarze - cały komentarz ma mieć jeden kolor
 - Doctype (niebieski)
 - tekst (dane) pozostaje bez zmian

Działanie:
+ ładuję tekst do parsera (kiedy i w jakich okolicznościach?) -> opis+schemat
+ z wywoływanych metod (tych, które przetwarzają tagi i dane - metody do nadpisania) modyfikuję tagi:
 - Co potrzebuję od każdej metody: indeksy początku/końca tekstu na jaki reaguje - jest tylko metoda getpos(), która zwraca (nr linii, offset) oraz metody handle_*(self, data), które w argumencie dostają zawartość elementu do którego się odnoszą (tag, atrybuty) - przy czym po każdym użyciu HTMLParser.parse należy obiekt zresetować, inaczej po każdym kolejnym wywołaniu getpos(), offset będzie się powiększał i nie będzie wskazywał rzeczywistej lokalizacji.
+ Widoczny obszar tekstu: przy pierwszym załadowaniu koloruję cały tekst, potem tylko wybrane fragmenty (ten który wyświetlam - w określonych odstępach czasu i w reakcji na zdarzenie modyfikacji)

Przepływ kontroli i struktura:
+ w konstruktorze ustawiam tagi dla poszczególnych typów tekstu
+ wczytuję tekst html do komponentu
+ wczytany tekst ładuję do parsera
+ metody wywoływane podczas analizy tekstu zwracają indeksy i nazwę tagu: (idx1, idx2, 'tag_name')
+ Parser ma metodę, która przypisuje tagi do indeksów w komponencie tk.Text - jest wywoływana razem z metodami handle* (metody do nadpisania, analizujące tekst - za pośrednictwem dekoratora, który jest przypisywany do każdej z tych metod automatycznie w momencie utworzenia instancji klasy - przez konstruktor?)
+ W parserze mogę mieć jedną ogólniejszą funkcję, np. handle_tag do której przekierowują argumenty funkcje b. szczegółowe, np. handle_starttag (i pozostałe), i która zwraca konkretne wartości (czy to na pewno ma sens? Sprawdzić jak będą te metody wyglądały jeżeli będę je pisał osobno).

aktualizacja tagów w tekście w widocznym tekście:
+ liczę czas między zdarzeniami (np. wciśnięciami klawisza)
+ jeżeli od ostatniego zdarzenia minęło więcej niż np. 1s-aktualizuję tekst


Uwagi:
+ może zamiast co określoną ilość czasu - niech aktualizuje podświetlanie co okr. ilość uderzeń klawiatury?
+ do zdarzeń czasowych w tkinter używa się tk.after()

+ jeżeli prócz tagu są atrybuty - metody otrzymują je jako: <h1 class="header"> -> [('class', 'header')] - ale: metodzie Text.tag_add wystarczy tylko początkowy indeks - może wraz z dodaniem nowego tagu poprzedni osadzony (w miejscu rozpoczęcia się nowego?)
 + jeżeli tag nie ma atrybutów: końcowy indeks - długość: "tag html+>"
+ znak '=' będę musiał chyba kolorować ręcznie
+ atrybut jest bez cudzysłowów -> trzeba je kolorować ręcznie
+ Żeby przyspieszyć działanie komponentu, można też dodać funkcję analizującą formatowanie wiersza w którym znajduje się kursor
+ czy wyszukiwanie atrybutów zadziała tak samo, jeżeli tekst atrybutu (nazwa i wartość) będą przedzielone pustą linią? -> zwraca dane ze znakami '\n'
+ jeżeli atrybut nie ma wartości, wówczas parsowany jest jako 'None'

***

+ handle_starttag() ma też kolorować atrybuty - może analizować to za pomocą wyr. reg?

jeżeli otrzymuje nazwy atrybutów:
+przetwarzam je w pętli:
 - znajduję w tekście nazwę atrybutu
 - ustalam przesunięcie względem początku tagu (init_index) - funkcja do ustalania pozycji napisu w obrębie drugiego napisu (substring) - str.find('substr')->init_idx
 - Czy jeżeli jest kilka atrybutów o tej samej nazwie a nawet tych samych wartościach, znajdą się one w argumencie attr? (Zakładam, że tak):
- jeżeli jest więcej niż jeden atrybut o danej nazwie: przetwarzanie rekurencyjnie - jak ta funkcja powinna wyglądać (par. wejściowe)

+ funkcja znajdująca wszystkie wystąpienia danej frazy w tekście

Wersja 1.
+ z listy attr mogę zrobić dwa zbiory (sets):
 1. nazwy atrybutów
 2. wartości atr

dla każdego z elementów jednego i drugiego zbioru (może osobne funkcje do tego zrobić?):
+ znajdować początkowe indeksy przy pomocy wyrażenia regularnego (zrobić listę tych indeksów)
+ kolorować te wystąpienia

Interesuje mnie dotąd
--------------------------------


dla każdego z tych zbiorów wywoływać funkcję ze zmienionym offsetem tak długo, aż nie dokona zmian (dojdzie do końca tagu), wtedy usuwać ten element

ZROBIĆ PROTOTYP TEJ FUNKCJI

highlight_attrs(pos : p.getpos(), offset=0 : 'przesunięcie względem początku tagu') -> apply_tag()

<meta property="og:url" property="prop2" content="https://stackoverflow.com/"/>

+ dodać kolorowanie pozostałych atr.